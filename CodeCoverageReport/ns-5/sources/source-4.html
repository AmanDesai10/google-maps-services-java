


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > RateLimiter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.google.maps.internal.ratelimiter</a>
</div>

<h1>Coverage Summary for Class: RateLimiter (com.google.maps.internal.ratelimiter)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RateLimiter</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (12/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (8/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.6%
  </span>
  <span class="absValue">
    (41/70)
  </span>
</td>
</tr>
  <tr>
    <td class="name">RateLimiter$SleepingStopwatch</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RateLimiter$SleepingStopwatch$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    65.4%
  </span>
  <span class="absValue">
    (17/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.5%
  </span>
  <span class="absValue">
    (10/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.8%
  </span>
  <span class="absValue">
    (49/78)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2012 The Guava Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
&nbsp; * in compliance with the License. You may obtain a copy of the License at
&nbsp; *
&nbsp; * http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software distributed under the License
&nbsp; * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
&nbsp; * or implied. See the License for the specific language governing permissions and limitations under
&nbsp; * the License.
&nbsp; */
&nbsp;/*
&nbsp; * Copyright 2017 Google Inc. All rights reserved.
&nbsp; *
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this
&nbsp; * file except in compliance with the License. You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software distributed under
&nbsp; * the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
&nbsp; * ANY KIND, either express or implied. See the License for the specific language governing
&nbsp; * permissions and limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package com.google.maps.internal.ratelimiter;
&nbsp;
&nbsp;import static com.google.maps.internal.ratelimiter.Preconditions.checkArgument;
&nbsp;import static com.google.maps.internal.ratelimiter.Preconditions.checkNotNull;
&nbsp;import static java.lang.Math.max;
&nbsp;import static java.util.concurrent.TimeUnit.MICROSECONDS;
&nbsp;import static java.util.concurrent.TimeUnit.NANOSECONDS;
&nbsp;import static java.util.concurrent.TimeUnit.SECONDS;
&nbsp;
&nbsp;import com.google.maps.internal.ratelimiter.SmoothRateLimiter.SmoothBursty;
&nbsp;import com.google.maps.internal.ratelimiter.SmoothRateLimiter.SmoothWarmingUp;
&nbsp;import java.util.Locale;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;
&nbsp;/**
&nbsp; * A rate limiter. Conceptually, a rate limiter distributes permits at a configurable rate. Each
&nbsp; * {@link #acquire()} blocks if necessary until a permit is available, and then takes it. Once
&nbsp; * acquired, permits need not be released.
&nbsp; *
&nbsp; * &lt;p&gt;Rate limiters are often used to restrict the rate at which some physical or logical resource
&nbsp; * is accessed. This is in contrast to {@link java.util.concurrent.Semaphore} which restricts the
&nbsp; * number of concurrent accesses instead of the rate (note though that concurrency and rate are
&nbsp; * closely related, e.g. see &lt;a href=&quot;http://en.wikipedia.org/wiki/Little%27s_law&quot;&gt;Little&#39;s
&nbsp; * Law&lt;/a&gt;).
&nbsp; *
&nbsp; * &lt;p&gt;A {@code RateLimiter} is defined primarily by the rate at which permits are issued. Absent
&nbsp; * additional configuration, permits will be distributed at a fixed rate, defined in terms of
&nbsp; * permits per second. Permits will be distributed smoothly, with the delay between individual
&nbsp; * permits being adjusted to ensure that the configured rate is maintained.
&nbsp; *
&nbsp; * &lt;p&gt;It is possible to configure a {@code RateLimiter} to have a warmup period during which time
&nbsp; * the permits issued each second steadily increases until it hits the stable rate.
&nbsp; *
&nbsp; * &lt;p&gt;As an example, imagine that we have a list of tasks to execute, but we don&#39;t want to submit
&nbsp; * more than 2 per second:
&nbsp; *
&nbsp; * &lt;pre&gt;{@code
&nbsp; * final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is &quot;2 permits per second&quot;
&nbsp; * void submitTasks(List&lt;Runnable&gt; tasks, Executor executor) {
&nbsp; *   for (Runnable task : tasks) {
&nbsp; *     rateLimiter.acquire(); // may wait
&nbsp; *     executor.execute(task);
&nbsp; *   }
&nbsp; * }
&nbsp; * }&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;As another example, imagine that we produce a stream of data, and we want to cap it at 5kb per
&nbsp; * second. This could be accomplished by requiring a permit per byte, and specifying a rate of 5000
&nbsp; * permits per second:
&nbsp; *
&nbsp; * &lt;pre&gt;{@code
&nbsp; * final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second
&nbsp; * void submitPacket(byte[] packet) {
&nbsp; *   rateLimiter.acquire(packet.length);
&nbsp; *   networkService.send(packet);
&nbsp; * }
&nbsp; * }&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;It is important to note that the number of permits requested &lt;i&gt;never&lt;/i&gt; affects the
&nbsp; * throttling of the request itself (an invocation to {@code acquire(1)} and an invocation to {@code
&nbsp; * acquire(1000)} will result in exactly the same throttling, if any), but it affects the throttling
&nbsp; * of the &lt;i&gt;next&lt;/i&gt; request. I.e., if an expensive task arrives at an idle RateLimiter, it will be
&nbsp; * granted immediately, but it is the &lt;i&gt;next&lt;/i&gt; request that will experience extra throttling,
&nbsp; * thus paying for the cost of the expensive task.
&nbsp; *
&nbsp; * &lt;p&gt;Note: {@code RateLimiter} does not provide fairness guarantees.
&nbsp; *
&nbsp; * @author Dimitris Andreou
&nbsp; * @since 13.0
&nbsp; */
<b class="fc">&nbsp;public abstract class RateLimiter {</b>
&nbsp;  /**
&nbsp;   * Creates a {@code RateLimiter} with the specified stable throughput, given as &quot;permits per
&nbsp;   * second&quot; (commonly referred to as &lt;i&gt;QPS&lt;/i&gt;, queries per second).
&nbsp;   *
&nbsp;   * &lt;p&gt;The returned {@code RateLimiter} ensures that on average no more than {@code
&nbsp;   * permitsPerSecond} are issued during any given second, with sustained requests being smoothly
&nbsp;   * spread over each second. When the incoming request rate exceeds {@code permitsPerSecond} the
&nbsp;   * rate limiter will release one permit every {@code (1.0 / permitsPerSecond)} seconds. When the
&nbsp;   * rate limiter is unused, bursts of up to {@code permitsPerSecond} permits will be allowed, with
&nbsp;   * subsequent requests being smoothly limited at the stable rate of {@code permitsPerSecond}.
&nbsp;   *
&nbsp;   * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in how many
&nbsp;   *     permits become available per second
&nbsp;   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero
&nbsp;   */
&nbsp;  public static RateLimiter create(double permitsPerSecond) {
&nbsp;    /*
&nbsp;     * The default RateLimiter configuration can save the unused permits of up to one second. This
&nbsp;     * is to avoid unnecessary stalls in situations like this: A RateLimiter of 1qps, and 4 threads,
&nbsp;     * all calling acquire() at these moments:
&nbsp;     *
&nbsp;     * T0 at 0 seconds
&nbsp;     * T1 at 1.05 seconds
&nbsp;     * T2 at 2 seconds
&nbsp;     * T3 at 3 seconds
&nbsp;     *
&nbsp;     * Due to the slight delay of T1, T2 would have to sleep till 2.05 seconds, and T3 would also
&nbsp;     * have to sleep till 3.05 seconds.
&nbsp;     */
<b class="nc">&nbsp;    return create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());</b>
&nbsp;  }
&nbsp;
&nbsp;  static RateLimiter create(double permitsPerSecond, SleepingStopwatch stopwatch) {
<b class="nc">&nbsp;    RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);</b>
<b class="nc">&nbsp;    rateLimiter.setRate(permitsPerSecond);</b>
<b class="nc">&nbsp;    return rateLimiter;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a {@code RateLimiter} with the specified stable throughput, given as &quot;permits per
&nbsp;   * second&quot; (commonly referred to as &lt;i&gt;QPS&lt;/i&gt;, queries per second), and a &lt;i&gt;warmup period&lt;/i&gt;,
&nbsp;   * during which the {@code RateLimiter} smoothly ramps up its rate, until it reaches its maximum
&nbsp;   * rate at the end of the period (as long as there are enough requests to saturate it). Similarly,
&nbsp;   * if the {@code RateLimiter} is left &lt;i&gt;unused&lt;/i&gt; for a duration of {@code warmupPeriod}, it
&nbsp;   * will gradually return to its &quot;cold&quot; state, i.e. it will go through the same warming up process
&nbsp;   * as when it was first created.
&nbsp;   *
&nbsp;   * &lt;p&gt;The returned {@code RateLimiter} is intended for cases where the resource that actually
&nbsp;   * fulfills the requests (e.g., a remote server) needs &quot;warmup&quot; time, rather than being
&nbsp;   * immediately accessed at the stable (maximum) rate.
&nbsp;   *
&nbsp;   * &lt;p&gt;The returned {@code RateLimiter} starts in a &quot;cold&quot; state (i.e. the warmup period will
&nbsp;   * follow), and if it is left unused for long enough, it will return to that state.
&nbsp;   *
&nbsp;   * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in how many
&nbsp;   *     permits become available per second
&nbsp;   * @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its rate,
&nbsp;   *     before reaching its stable (maximum) rate
&nbsp;   * @param unit the time unit of the warmupPeriod argument
&nbsp;   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or {@code
&nbsp;   *     warmupPeriod} is negative
&nbsp;   */
&nbsp;  public static RateLimiter create(double permitsPerSecond, long warmupPeriod, TimeUnit unit) {
<b class="pc">&nbsp;    checkArgument(warmupPeriod &gt;= 0, &quot;warmupPeriod must not be negative: %s&quot;, warmupPeriod);</b>
<b class="fc">&nbsp;    return create(</b>
<b class="fc">&nbsp;        permitsPerSecond, warmupPeriod, unit, 3.0, SleepingStopwatch.createFromSystemTimer());</b>
&nbsp;  }
&nbsp;
&nbsp;  static RateLimiter create(
&nbsp;      double permitsPerSecond,
&nbsp;      long warmupPeriod,
&nbsp;      TimeUnit unit,
&nbsp;      double coldFactor,
&nbsp;      SleepingStopwatch stopwatch) {
<b class="fc">&nbsp;    RateLimiter rateLimiter = new SmoothWarmingUp(stopwatch, warmupPeriod, unit, coldFactor);</b>
<b class="fc">&nbsp;    rateLimiter.setRate(permitsPerSecond);</b>
<b class="fc">&nbsp;    return rateLimiter;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The underlying timer; used both to measure elapsed time and sleep as necessary. A separate
&nbsp;   * object to facilitate testing.
&nbsp;   */
&nbsp;  private final SleepingStopwatch stopwatch;
&nbsp;
&nbsp;  // Can&#39;t be initialized in the constructor because mocks don&#39;t call the constructor.
&nbsp;  private volatile Object mutexDoNotUseDirectly;
&nbsp;
&nbsp;  private Object mutex() {
<b class="fc">&nbsp;    Object mutex = mutexDoNotUseDirectly;</b>
<b class="fc">&nbsp;    if (mutex == null) {</b>
<b class="fc">&nbsp;      synchronized (this) {</b>
<b class="fc">&nbsp;        mutex = mutexDoNotUseDirectly;</b>
<b class="pc">&nbsp;        if (mutex == null) {</b>
<b class="fc">&nbsp;          mutexDoNotUseDirectly = mutex = new Object();</b>
&nbsp;        }
<b class="fc">&nbsp;      }</b>
&nbsp;    }
<b class="fc">&nbsp;    return mutex;</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  RateLimiter(SleepingStopwatch stopwatch) {</b>
<b class="fc">&nbsp;    this.stopwatch = checkNotNull(stopwatch);</b>
<b class="fc">&nbsp;  }</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Updates the stable rate of this {@code RateLimiter}, that is, the {@code permitsPerSecond}
&nbsp;   * argument provided in the factory method that constructed the {@code RateLimiter}. Currently
&nbsp;   * throttled threads will &lt;b&gt;not&lt;/b&gt; be awakened as a result of this invocation, thus they do not
&nbsp;   * observe the new rate; only subsequent requests will.
&nbsp;   *
&nbsp;   * &lt;p&gt;Note though that, since each request repays (by waiting, if necessary) the cost of the
&nbsp;   * &lt;i&gt;previous&lt;/i&gt; request, this means that the very next request after an invocation to {@code
&nbsp;   * setRate} will not be affected by the new rate; it will pay the cost of the previous request,
&nbsp;   * which is in terms of the previous rate.
&nbsp;   *
&nbsp;   * &lt;p&gt;The behavior of the {@code RateLimiter} is not modified in any other way, e.g. if the {@code
&nbsp;   * RateLimiter} was configured with a warmup period of 20 seconds, it still has a warmup period of
&nbsp;   * 20 seconds after this method invocation.
&nbsp;   *
&nbsp;   * @param permitsPerSecond the new stable rate of this {@code RateLimiter}
&nbsp;   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero
&nbsp;   */
&nbsp;  public final void setRate(double permitsPerSecond) {
<b class="pc">&nbsp;    checkArgument(</b>
<b class="pc">&nbsp;        permitsPerSecond &gt; 0.0 &amp;&amp; !Double.isNaN(permitsPerSecond), &quot;rate must be positive&quot;);</b>
<b class="fc">&nbsp;    synchronized (mutex()) {</b>
<b class="fc">&nbsp;      doSetRate(permitsPerSecond, stopwatch.readMicros());</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;  }</b>
&nbsp;
&nbsp;  abstract void doSetRate(double permitsPerSecond, long nowMicros);
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the stable rate (as {@code permits per seconds}) with which this {@code RateLimiter} is
&nbsp;   * configured with. The initial value of this is the same as the {@code permitsPerSecond} argument
&nbsp;   * passed in the factory method that produced this {@code RateLimiter}, and it is only updated
&nbsp;   * after invocations to {@linkplain #setRate}.
&nbsp;   */
&nbsp;  public final double getRate() {
<b class="nc">&nbsp;    synchronized (mutex()) {</b>
<b class="nc">&nbsp;      return doGetRate();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  abstract double doGetRate();
&nbsp;
&nbsp;  /**
&nbsp;   * Acquires a single permit from this {@code RateLimiter}, blocking until the request can be
&nbsp;   * granted. Tells the amount of time slept, if any.
&nbsp;   *
&nbsp;   * &lt;p&gt;This method is equivalent to {@code acquire(1)}.
&nbsp;   *
&nbsp;   * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited
&nbsp;   * @since 16.0 (present in 13.0 with {@code void} return type})
&nbsp;   */
&nbsp;  public double acquire() {
<b class="fc">&nbsp;    return acquire(1);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Acquires the given number of permits from this {@code RateLimiter}, blocking until the request
&nbsp;   * can be granted. Tells the amount of time slept, if any.
&nbsp;   *
&nbsp;   * @param permits the number of permits to acquire
&nbsp;   * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited
&nbsp;   * @throws IllegalArgumentException if the requested number of permits is negative or zero
&nbsp;   * @since 16.0 (present in 13.0 with {@code void} return type})
&nbsp;   */
&nbsp;  public double acquire(int permits) {
<b class="fc">&nbsp;    long microsToWait = reserve(permits);</b>
<b class="fc">&nbsp;    stopwatch.sleepMicrosUninterruptibly(microsToWait);</b>
<b class="fc">&nbsp;    return 1.0 * microsToWait / SECONDS.toMicros(1L);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reserves the given number of permits from this {@code RateLimiter} for future use, returning
&nbsp;   * the number of microseconds until the reservation can be consumed.
&nbsp;   *
&nbsp;   * @return time in microseconds to wait until the resource can be acquired, never negative
&nbsp;   */
&nbsp;  final long reserve(int permits) {
<b class="fc">&nbsp;    checkPermits(permits);</b>
<b class="fc">&nbsp;    synchronized (mutex()) {</b>
<b class="fc">&nbsp;      return reserveAndGetWaitLength(permits, stopwatch.readMicros());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Acquires a permit from this {@code RateLimiter} if it can be obtained without exceeding the
&nbsp;   * specified {@code timeout}, or returns {@code false} immediately (without waiting) if the permit
&nbsp;   * would not have been granted before the timeout expired.
&nbsp;   *
&nbsp;   * &lt;p&gt;This method is equivalent to {@code tryAcquire(1, timeout, unit)}.
&nbsp;   *
&nbsp;   * @param timeout the maximum time to wait for the permit. Negative values are treated as zero.
&nbsp;   * @param unit the time unit of the timeout argument
&nbsp;   * @return {@code true} if the permit was acquired, {@code false} otherwise
&nbsp;   * @throws IllegalArgumentException if the requested number of permits is negative or zero
&nbsp;   */
&nbsp;  public boolean tryAcquire(long timeout, TimeUnit unit) {
<b class="nc">&nbsp;    return tryAcquire(1, timeout, unit);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Acquires permits from this {@link RateLimiter} if it can be acquired immediately without delay.
&nbsp;   *
&nbsp;   * &lt;p&gt;This method is equivalent to {@code tryAcquire(permits, 0, anyUnit)}.
&nbsp;   *
&nbsp;   * @param permits the number of permits to acquire
&nbsp;   * @return {@code true} if the permits were acquired, {@code false} otherwise
&nbsp;   * @throws IllegalArgumentException if the requested number of permits is negative or zero
&nbsp;   * @since 14.0
&nbsp;   */
&nbsp;  public boolean tryAcquire(int permits) {
<b class="nc">&nbsp;    return tryAcquire(permits, 0, MICROSECONDS);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Acquires a permit from this {@link RateLimiter} if it can be acquired immediately without
&nbsp;   * delay.
&nbsp;   *
&nbsp;   * &lt;p&gt;This method is equivalent to {@code tryAcquire(1)}.
&nbsp;   *
&nbsp;   * @return {@code true} if the permit was acquired, {@code false} otherwise
&nbsp;   * @since 14.0
&nbsp;   */
&nbsp;  public boolean tryAcquire() {
<b class="nc">&nbsp;    return tryAcquire(1, 0, MICROSECONDS);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained
&nbsp;   * without exceeding the specified {@code timeout}, or returns {@code false} immediately (without
&nbsp;   * waiting) if the permits would not have been granted before the timeout expired.
&nbsp;   *
&nbsp;   * @param permits the number of permits to acquire
&nbsp;   * @param timeout the maximum time to wait for the permits. Negative values are treated as zero.
&nbsp;   * @param unit the time unit of the timeout argument
&nbsp;   * @return {@code true} if the permits were acquired, {@code false} otherwise
&nbsp;   * @throws IllegalArgumentException if the requested number of permits is negative or zero
&nbsp;   */
&nbsp;  public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {
<b class="nc">&nbsp;    long timeoutMicros = max(unit.toMicros(timeout), 0);</b>
<b class="nc">&nbsp;    checkPermits(permits);</b>
&nbsp;    long microsToWait;
<b class="nc">&nbsp;    synchronized (mutex()) {</b>
<b class="nc">&nbsp;      long nowMicros = stopwatch.readMicros();</b>
<b class="nc">&nbsp;      if (!canAcquire(nowMicros, timeoutMicros)) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        microsToWait = reserveAndGetWaitLength(permits, nowMicros);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    stopwatch.sleepMicrosUninterruptibly(microsToWait);</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean canAcquire(long nowMicros, long timeoutMicros) {
<b class="nc">&nbsp;    return queryEarliestAvailable(nowMicros) - timeoutMicros &lt;= nowMicros;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reserves next ticket and returns the wait time that the caller must wait for.
&nbsp;   *
&nbsp;   * @return the required wait time, never negative
&nbsp;   */
&nbsp;  final long reserveAndGetWaitLength(int permits, long nowMicros) {
<b class="fc">&nbsp;    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);</b>
<b class="fc">&nbsp;    return max(momentAvailable - nowMicros, 0);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the earliest time that permits are available (with one caveat).
&nbsp;   *
&nbsp;   * @return the time that permits are available, or, if permits are available immediately, an
&nbsp;   *     arbitrary past or present time
&nbsp;   */
&nbsp;  abstract long queryEarliestAvailable(long nowMicros);
&nbsp;
&nbsp;  /**
&nbsp;   * Reserves the requested number of permits and returns the time that those permits can be used
&nbsp;   * (with one caveat).
&nbsp;   *
&nbsp;   * @return the time that the permits may be used, or, if the permits may be used immediately, an
&nbsp;   *     arbitrary past or present time
&nbsp;   */
&nbsp;  abstract long reserveEarliestAvailable(int permits, long nowMicros);
&nbsp;
&nbsp;  @Override
&nbsp;  public String toString() {
<b class="nc">&nbsp;    return String.format(Locale.ROOT, &quot;RateLimiter[stableRate=%3.1fqps]&quot;, getRate());</b>
&nbsp;  }
&nbsp;
&nbsp;  abstract static class SleepingStopwatch {
&nbsp;    /** Constructor for use by subclasses. */
<b class="fc">&nbsp;    protected SleepingStopwatch() {}</b>
&nbsp;
&nbsp;    /*
&nbsp;     * We always hold the mutex when calling this.
&nbsp;     */
&nbsp;    protected abstract long readMicros();
&nbsp;
&nbsp;    protected abstract void sleepMicrosUninterruptibly(long micros);
&nbsp;
&nbsp;    public static SleepingStopwatch createFromSystemTimer() {
<b class="fc">&nbsp;      return new SleepingStopwatch() {</b>
<b class="fc">&nbsp;        final Stopwatch stopwatch = Stopwatch.createStarted();</b>
&nbsp;
&nbsp;        @Override
&nbsp;        protected long readMicros() {
<b class="fc">&nbsp;          return stopwatch.elapsed(MICROSECONDS);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void sleepMicrosUninterruptibly(long micros) {
<b class="fc">&nbsp;          if (micros &gt; 0) {</b>
<b class="fc">&nbsp;            sleepUninterruptibly(micros, MICROSECONDS);</b>
&nbsp;          }
<b class="fc">&nbsp;        }</b>
&nbsp;      };
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static void checkPermits(int permits) {
<b class="pc">&nbsp;    checkArgument(permits &gt; 0, &quot;Requested permits (%s) must be positive&quot;, permits);</b>
<b class="fc">&nbsp;  }</b>
&nbsp;
&nbsp;  /** Invokes {@code unit.}{@link TimeUnit#sleep(long) sleep(sleepFor)} uninterruptibly. */
&nbsp;  private static void sleepUninterruptibly(long sleepFor, TimeUnit unit) {
<b class="fc">&nbsp;    boolean interrupted = false;</b>
&nbsp;    try {
<b class="fc">&nbsp;      long remainingNanos = unit.toNanos(sleepFor);</b>
<b class="fc">&nbsp;      long end = System.nanoTime() + remainingNanos;</b>
&nbsp;      while (true) {
&nbsp;        try {
&nbsp;          // TimeUnit.sleep() treats negative timeouts just like zero.
<b class="fc">&nbsp;          NANOSECONDS.sleep(remainingNanos);</b>
<b class="fc">&nbsp;          return;</b>
<b class="nc">&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;          interrupted = true;</b>
<b class="nc">&nbsp;          remainingNanos = end - System.nanoTime();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;      }
&nbsp;    } finally {
<b class="pc">&nbsp;      if (interrupted) {</b>
<b class="nc">&nbsp;        Thread.currentThread().interrupt();</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-01 14:27</div>
</div>
</body>
</html>
