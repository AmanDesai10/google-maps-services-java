


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > OkHttpPendingResult</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.google.maps.internal</a>
</div>

<h1>Coverage Summary for Class: OkHttpPendingResult (com.google.maps.internal)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">OkHttpPendingResult</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (12/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.1%
  </span>
  <span class="absValue">
    (26/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.8%
  </span>
  <span class="absValue">
    (99/114)
  </span>
</td>
</tr>
  <tr>
    <td class="name">OkHttpPendingResult$1</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OkHttpPendingResult$QueuedResponse</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    54.5%
  </span>
  <span class="absValue">
    (6/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (16/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.1%
  </span>
  <span class="absValue">
    (26/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.6%
  </span>
  <span class="absValue">
    (109/132)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 Google Inc. All rights reserved.
&nbsp; *
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this
&nbsp; * file except in compliance with the License. You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software distributed under
&nbsp; * the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
&nbsp; * ANY KIND, either express or implied. See the License for the specific language governing
&nbsp; * permissions and limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package com.google.maps.internal;
&nbsp;
&nbsp;import com.google.gson.FieldNamingPolicy;
&nbsp;import com.google.gson.Gson;
&nbsp;import com.google.gson.GsonBuilder;
&nbsp;import com.google.gson.JsonSyntaxException;
&nbsp;import com.google.maps.GeolocationApi;
&nbsp;import com.google.maps.ImageResult;
&nbsp;import com.google.maps.PendingResult;
&nbsp;import com.google.maps.errors.ApiException;
&nbsp;import com.google.maps.metrics.RequestMetrics;
&nbsp;import com.google.maps.model.AddressComponentType;
&nbsp;import com.google.maps.model.AddressType;
&nbsp;import com.google.maps.model.Distance;
&nbsp;import com.google.maps.model.Duration;
&nbsp;import com.google.maps.model.Fare;
&nbsp;import com.google.maps.model.LatLng;
&nbsp;import com.google.maps.model.LocationType;
&nbsp;import com.google.maps.model.OpeningHours.Period.OpenClose.DayOfWeek;
&nbsp;import com.google.maps.model.PlaceDetails.Review.AspectRating.RatingType;
&nbsp;import com.google.maps.model.PriceLevel;
&nbsp;import com.google.maps.model.TravelMode;
&nbsp;import com.google.maps.model.VehicleType;
&nbsp;import java.io.IOException;
&nbsp;import java.time.Instant;
&nbsp;import java.time.LocalTime;
&nbsp;import java.time.ZonedDateTime;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;import java.util.concurrent.ArrayBlockingQueue;
&nbsp;import java.util.concurrent.BlockingQueue;
&nbsp;import okhttp3.Call;
&nbsp;import okhttp3.Callback;
&nbsp;import okhttp3.OkHttpClient;
&nbsp;import okhttp3.Request;
&nbsp;import okhttp3.Response;
&nbsp;import okhttp3.ResponseBody;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * A PendingResult backed by a HTTP call executed by OkHttp, a deserialization step using Gson, rate
&nbsp; * limiting and a retry policy.
&nbsp; *
&nbsp; * &lt;p&gt;{@code T} is the type of the result of this pending result, and {@code R} is the type of the
&nbsp; * request.
&nbsp; */
<b class="fc">&nbsp;public class OkHttpPendingResult&lt;T, R extends ApiResponse&lt;T&gt;&gt;</b>
&nbsp;    implements PendingResult&lt;T&gt;, Callback {
&nbsp;  private final Request request;
&nbsp;  private final OkHttpClient client;
&nbsp;  private final Class&lt;R&gt; responseClass;
&nbsp;  private final FieldNamingPolicy fieldNamingPolicy;
&nbsp;  private final Integer maxRetries;
&nbsp;  private final RequestMetrics metrics;
&nbsp;
&nbsp;  private Call call;
&nbsp;  private Callback&lt;T&gt; callback;
&nbsp;  private long errorTimeOut;
<b class="fc">&nbsp;  private int retryCounter = 0;</b>
<b class="fc">&nbsp;  private long cumulativeSleepTime = 0;</b>
&nbsp;  private ExceptionsAllowedToRetry exceptionsAllowedToRetry;
&nbsp;
<b class="fc">&nbsp;  private static final Logger LOG = LoggerFactory.getLogger(OkHttpPendingResult.class.getName());</b>
<b class="fc">&nbsp;  private static final List&lt;Integer&gt; RETRY_ERROR_CODES = Arrays.asList(500, 503, 504);</b>
&nbsp;
&nbsp;  /**
&nbsp;   * @param request HTTP request to execute.
&nbsp;   * @param client The client used to execute the request.
&nbsp;   * @param responseClass Model class to unmarshal JSON body content.
&nbsp;   * @param fieldNamingPolicy FieldNamingPolicy for unmarshaling JSON.
&nbsp;   * @param errorTimeOut Number of milliseconds to re-send erroring requests.
&nbsp;   * @param maxRetries Number of times allowed to re-send erroring requests.
&nbsp;   * @param exceptionsAllowedToRetry The exceptions to retry.
&nbsp;   */
&nbsp;  public OkHttpPendingResult(
&nbsp;      Request request,
&nbsp;      OkHttpClient client,
&nbsp;      Class&lt;R&gt; responseClass,
&nbsp;      FieldNamingPolicy fieldNamingPolicy,
&nbsp;      long errorTimeOut,
&nbsp;      Integer maxRetries,
&nbsp;      ExceptionsAllowedToRetry exceptionsAllowedToRetry,
<b class="fc">&nbsp;      RequestMetrics metrics) {</b>
<b class="fc">&nbsp;    this.request = request;</b>
<b class="fc">&nbsp;    this.client = client;</b>
<b class="fc">&nbsp;    this.responseClass = responseClass;</b>
<b class="fc">&nbsp;    this.fieldNamingPolicy = fieldNamingPolicy;</b>
<b class="fc">&nbsp;    this.errorTimeOut = errorTimeOut;</b>
<b class="fc">&nbsp;    this.maxRetries = maxRetries;</b>
<b class="fc">&nbsp;    this.exceptionsAllowedToRetry = exceptionsAllowedToRetry;</b>
<b class="fc">&nbsp;    this.metrics = metrics;</b>
&nbsp;
<b class="fc">&nbsp;    metrics.startNetwork();</b>
<b class="fc">&nbsp;    this.call = client.newCall(request);</b>
<b class="fc">&nbsp;  }</b>
&nbsp;
&nbsp;  @Override
&nbsp;  public void setCallback(Callback&lt;T&gt; callback) {
<b class="fc">&nbsp;    this.callback = callback;</b>
<b class="fc">&nbsp;    call.enqueue(this);</b>
<b class="fc">&nbsp;  }</b>
&nbsp;
&nbsp;  /** Preserve a request/response pair through an asynchronous callback. */
<b class="fc">&nbsp;  private class QueuedResponse {</b>
&nbsp;    private final OkHttpPendingResult&lt;T, R&gt; request;
&nbsp;    private final Response response;
&nbsp;    private final IOException e;
&nbsp;
<b class="fc">&nbsp;    public QueuedResponse(OkHttpPendingResult&lt;T, R&gt; request, Response response) {</b>
<b class="fc">&nbsp;      this.request = request;</b>
<b class="fc">&nbsp;      this.response = response;</b>
<b class="fc">&nbsp;      this.e = null;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public QueuedResponse(OkHttpPendingResult&lt;T, R&gt; request, IOException e) {</b>
<b class="nc">&nbsp;      this.request = request;</b>
<b class="nc">&nbsp;      this.response = null;</b>
<b class="nc">&nbsp;      this.e = e;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public T await() throws ApiException, IOException, InterruptedException {
&nbsp;    // Handle sleeping for retried requests
<b class="fc">&nbsp;    if (retryCounter &gt; 0) {</b>
&nbsp;      // 0.5 * (1.5 ^ i) represents an increased sleep time of 1.5x per iteration,
&nbsp;      // starting at 0.5s when i = 0. The retryCounter will be 1 for the 1st retry,
&nbsp;      // so subtract 1 here.
<b class="fc">&nbsp;      double delaySecs = 0.5 * Math.pow(1.5, retryCounter - 1);</b>
&nbsp;
&nbsp;      // Generate a jitter value between -delaySecs / 2 and +delaySecs / 2
<b class="fc">&nbsp;      long delayMillis = (long) (delaySecs * (Math.random() + 0.5) * 1000);</b>
&nbsp;
<b class="fc">&nbsp;      LOG.debug(</b>
<b class="fc">&nbsp;          String.format(</b>
&nbsp;              &quot;Sleeping between errors for %dms (retry #%d, already slept %dms)&quot;,
<b class="fc">&nbsp;              delayMillis, retryCounter, cumulativeSleepTime));</b>
<b class="fc">&nbsp;      cumulativeSleepTime += delayMillis;</b>
&nbsp;      try {
<b class="fc">&nbsp;        Thread.sleep(delayMillis);</b>
<b class="nc">&nbsp;      } catch (InterruptedException e) {</b>
&nbsp;        // No big deal if we don&#39;t sleep as long as intended.
<b class="fc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    final BlockingQueue&lt;QueuedResponse&gt; waiter = new ArrayBlockingQueue&lt;&gt;(1);</b>
<b class="fc">&nbsp;    final OkHttpPendingResult&lt;T, R&gt; parent = this;</b>
&nbsp;
&nbsp;    // This callback will be called on another thread, handled by the RateLimitExecutorService.
&nbsp;    // Calling call.execute() directly would bypass the rate limiting.
<b class="fc">&nbsp;    call.enqueue(</b>
<b class="fc">&nbsp;        new okhttp3.Callback() {</b>
&nbsp;          @Override
&nbsp;          public void onFailure(Call call, IOException e) {
<b class="nc">&nbsp;            metrics.endNetwork();</b>
<b class="nc">&nbsp;            waiter.add(new QueuedResponse(parent, e));</b>
<b class="nc">&nbsp;          }</b>
&nbsp;
&nbsp;          @Override
&nbsp;          public void onResponse(Call call, Response response) throws IOException {
<b class="fc">&nbsp;            metrics.endNetwork();</b>
<b class="fc">&nbsp;            waiter.add(new QueuedResponse(parent, response));</b>
<b class="fc">&nbsp;          }</b>
&nbsp;        });
&nbsp;
<b class="fc">&nbsp;    QueuedResponse r = waiter.take();</b>
<b class="pc">&nbsp;    if (r.response != null) {</b>
<b class="fc">&nbsp;      return parseResponse(r.request, r.response);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      metrics.endRequest(r.e, 0, retryCounter);</b>
<b class="nc">&nbsp;      throw r.e;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public T awaitIgnoreError() {
&nbsp;    try {
<b class="fc">&nbsp;      return await();</b>
<b class="fc">&nbsp;    } catch (Exception e) {</b>
<b class="fc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public void cancel() {
<b class="nc">&nbsp;    call.cancel();</b>
<b class="nc">&nbsp;  }</b>
&nbsp;
&nbsp;  @Override
&nbsp;  public void onFailure(Call call, IOException ioe) {
<b class="nc">&nbsp;    metrics.endNetwork();</b>
<b class="nc">&nbsp;    if (callback != null) {</b>
<b class="nc">&nbsp;      metrics.endRequest(ioe, 0, retryCounter);</b>
<b class="nc">&nbsp;      callback.onFailure(ioe);</b>
&nbsp;    }
<b class="nc">&nbsp;  }</b>
&nbsp;
&nbsp;  @Override
&nbsp;  public void onResponse(Call call, Response response) throws IOException {
<b class="fc">&nbsp;    metrics.endNetwork();</b>
<b class="pc">&nbsp;    if (callback != null) {</b>
&nbsp;      try {
<b class="fc">&nbsp;        callback.onResult(parseResponse(this, response));</b>
<b class="nc">&nbsp;      } catch (Exception e) {</b>
<b class="nc">&nbsp;        callback.onFailure(e);</b>
<b class="fc">&nbsp;      }</b>
&nbsp;    }
<b class="fc">&nbsp;  }</b>
&nbsp;
&nbsp;  @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;  private T parseResponse(OkHttpPendingResult&lt;T, R&gt; request, Response response)
&nbsp;      throws ApiException, InterruptedException, IOException {
&nbsp;    try {
<b class="fc">&nbsp;      T result = parseResponseInternal(request, response);</b>
<b class="fc">&nbsp;      metrics.endRequest(null, response.code(), retryCounter);</b>
<b class="fc">&nbsp;      return result;</b>
<b class="fc">&nbsp;    } catch (Exception e) {</b>
<b class="fc">&nbsp;      metrics.endRequest(e, response.code(), retryCounter);</b>
<b class="fc">&nbsp;      throw e;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;  private T parseResponseInternal(OkHttpPendingResult&lt;T, R&gt; request, Response response)
&nbsp;      throws ApiException, InterruptedException, IOException {
<b class="fc">&nbsp;    if (shouldRetry(response)) {</b>
&nbsp;      // since we are retrying the request we must close the response
<b class="fc">&nbsp;      response.close();</b>
&nbsp;
&nbsp;      // Retry is a blocking method, but that&#39;s OK. If we&#39;re here, we&#39;re either in an await()
&nbsp;      // call, which is blocking anyway, or we&#39;re handling a callback in a separate thread.
<b class="fc">&nbsp;      return request.retry();</b>
&nbsp;    }
&nbsp;
&nbsp;    byte[] bytes;
<b class="pc">&nbsp;    try (ResponseBody body = response.body()) {</b>
<b class="fc">&nbsp;      bytes = body.bytes();</b>
<b class="pc">&nbsp;    }</b>
&nbsp;    R resp;
<b class="fc">&nbsp;    String contentType = response.header(&quot;Content-Type&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    if (contentType != null</b>
<b class="pc">&nbsp;        &amp;&amp; contentType.startsWith(&quot;image&quot;)</b>
&nbsp;        &amp;&amp; responseClass == ImageResult.Response.class
<b class="pc">&nbsp;        &amp;&amp; response.code() == 200) {</b>
<b class="fc">&nbsp;      ImageResult result = new ImageResult(contentType, bytes);</b>
<b class="fc">&nbsp;      return (T) result;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    Gson gson =</b>
&nbsp;        new GsonBuilder()
<b class="fc">&nbsp;            .registerTypeAdapter(ZonedDateTime.class, new ZonedDateTimeAdapter())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(Distance.class, new DistanceAdapter())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(Duration.class, new DurationAdapter())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(Fare.class, new FareAdapter())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(LatLng.class, new LatLngAdapter())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(</b>
&nbsp;                AddressComponentType.class,
&nbsp;                new SafeEnumAdapter&lt;AddressComponentType&gt;(AddressComponentType.UNKNOWN))
<b class="fc">&nbsp;            .registerTypeAdapter(</b>
&nbsp;                AddressType.class, new SafeEnumAdapter&lt;AddressType&gt;(AddressType.UNKNOWN))
<b class="fc">&nbsp;            .registerTypeAdapter(</b>
&nbsp;                TravelMode.class, new SafeEnumAdapter&lt;TravelMode&gt;(TravelMode.UNKNOWN))
<b class="fc">&nbsp;            .registerTypeAdapter(</b>
&nbsp;                LocationType.class, new SafeEnumAdapter&lt;LocationType&gt;(LocationType.UNKNOWN))
<b class="fc">&nbsp;            .registerTypeAdapter(</b>
&nbsp;                RatingType.class, new SafeEnumAdapter&lt;RatingType&gt;(RatingType.UNKNOWN))
<b class="fc">&nbsp;            .registerTypeAdapter(</b>
&nbsp;                VehicleType.class, new SafeEnumAdapter&lt;VehicleType&gt;(VehicleType.OTHER))
<b class="fc">&nbsp;            .registerTypeAdapter(DayOfWeek.class, new DayOfWeekAdapter())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(PriceLevel.class, new PriceLevelAdapter())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(Instant.class, new InstantAdapter())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(LocalTime.class, new LocalTimeAdapter())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(GeolocationApi.Response.class, new GeolocationResponseAdapter())</b>
<b class="fc">&nbsp;            .setFieldNamingPolicy(fieldNamingPolicy)</b>
<b class="fc">&nbsp;            .create();</b>
&nbsp;
&nbsp;    // Attempt to de-serialize before checking the HTTP status code, as there may be JSON in the
&nbsp;    // body that we can use to provide a more descriptive exception.
&nbsp;    try {
<b class="fc">&nbsp;      resp = gson.fromJson(new String(bytes, &quot;utf8&quot;), responseClass);</b>
<b class="fc">&nbsp;    } catch (JsonSyntaxException e) {</b>
&nbsp;      // Check HTTP status for a more suitable exception
<b class="pc">&nbsp;      if (!response.isSuccessful()) {</b>
&nbsp;        // Some of the APIs return 200 even when the API request fails, as long as the transport
&nbsp;        // mechanism succeeds. In these cases, INVALID_RESPONSE, etc are handled by the Gson
&nbsp;        // parsing.
<b class="fc">&nbsp;        throw new IOException(</b>
<b class="fc">&nbsp;            String.format(&quot;Server Error: %d %s&quot;, response.code(), response.message()));</b>
&nbsp;      }
&nbsp;
&nbsp;      // Otherwise just cough up the syntax exception.
<b class="nc">&nbsp;      throw e;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    if (resp.successful()) {</b>
&nbsp;      // Return successful responses
<b class="fc">&nbsp;      return resp.getResult();</b>
&nbsp;    } else {
<b class="fc">&nbsp;      ApiException e = resp.getError();</b>
<b class="pc">&nbsp;      if (shouldRetry(e)) {</b>
<b class="nc">&nbsp;        return request.retry();</b>
&nbsp;      } else {
<b class="fc">&nbsp;        throw e;</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private T retry() throws ApiException, InterruptedException, IOException {
<b class="fc">&nbsp;    retryCounter++;</b>
<b class="fc">&nbsp;    LOG.info(&quot;Retrying request. Retry #&quot; + retryCounter);</b>
<b class="fc">&nbsp;    metrics.startNetwork();</b>
<b class="fc">&nbsp;    this.call = client.newCall(request);</b>
<b class="fc">&nbsp;    return this.await();</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean shouldRetry(Response response) {
<b class="fc">&nbsp;    return RETRY_ERROR_CODES.contains(response.code())</b>
&nbsp;        &amp;&amp; cumulativeSleepTime &lt; errorTimeOut
<b class="fc">&nbsp;        &amp;&amp; (maxRetries == null || retryCounter &lt; maxRetries);</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean shouldRetry(ApiException exception) {
<b class="pc">&nbsp;    return exceptionsAllowedToRetry.contains(exception.getClass())</b>
&nbsp;        &amp;&amp; cumulativeSleepTime &lt; errorTimeOut
<b class="nc">&nbsp;        &amp;&amp; (maxRetries == null || retryCounter &lt; maxRetries);</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-01 14:27</div>
</div>
</body>
</html>
